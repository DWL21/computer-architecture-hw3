# RISC-V Simulator A 벤치마크 최적화 리포트

## 📋 프로젝트 개요

### 시뮬레이터 구조
- **아키텍처**: RISC-V 64비트 파이프라인 시뮬레이터
- **파이프라인**: 5단계 (Fetch → Decode → Execute → Memory → WriteBack)
- **캐시 시스템**: 계층형 L1/L2 캐시
- **분기 예측**: 4가지 전략 지원 (AT, NT, BTFNT, BPB)

### A 벤치마크 분석
- **알고리즘**: 35×35 행렬 곱셈 (Matrix Multiplication)
- **특성**: 메모리 집약적 워크로드
- **연산량**: O(n³) = 42,875 곱셈 연산
- **메모리 패턴**: 순차적 및 스트라이드 접근

```c
void func_A(int a[][SIZE], int b[][SIZE], int c[][SIZE]) {
    for (i = 0; i < SIZE; i++)
        for (j = 0; j < SIZE; j++)
            for (k = 0; k < SIZE; k++)
                c[i][j] += a[i][k] * b[k][j];
}
```

## 🚀 최적화 과정

### 초기 상태 분석
**원본 설정 (configA)**:
```
l1.cacheSize=2048
l1.blockSize=64
l1.associativity=2
l2.cacheSize=16384
l2.blockSize=64
l2.associativity=2
bp=BPB
```

**초기 성능**:
- Benchmark Score: **0.9744**
- 사이클 수: 6,907,164
- CPI: 1.6366
- 명령어 수: 4,220,359

## 📊 체계적 최적화 과정 및 결과

### 단계별 최적화 결과표

| 단계 | 변경 사항 | L1 Size | L1 Block | L1 Assoc | L2 Size | L2 Block | L2 Assoc | **점수** | 비고 |
|------|-----------|---------|----------|----------|---------|----------|----------|----------|------|
| 0 | 초기 설정 | 2048 | 64 | 2 | 16384 | 64 | 2 | **0.9744** | 기준점 |
| 1 | L1 크기 감소 | 1024 | 64 | 2 | 16384 | 64 | 2 | **0.8798** | ❌ 성능 저하 |
| 2 | L1 크기 증가 | 4096 | 64 | 2 | 16384 | 64 | 2 | **0.9833** | ✅ 소폭 개선 |
| 3 | L1 크기 더 증가 | 8192 | 64 | 2 | 16384 | 64 | 2 | **0.9620** | ❌ 오히려 저하 |
| 4 | L1 연관도 증가 | 4096 | 64 | 4 | 16384 | 64 | 2 | **0.9708** | ❌ 성능 저하 |
| 5 | L1 블록 크기 감소 | 4096 | 32 | 2 | 16384 | 64 | 2 | **1.0636** | ✅ 큰 향상! |
| 6 | L2 크기 감소 | 4096 | 32 | 2 | 8192 | 64 | 2 | **1.0778** | ✅ 추가 개선 |
| 7 | L2 크기 더 감소 | 4096 | 32 | 2 | 4096 | 64 | 2 | **1.0689** | ❌ 너무 작음 |
| 8 | L2 블록 크기 감소 | 4096 | 32 | 2 | 8192 | 32 | 2 | **1.0967** | ✅ 더 개선 |
| 9 | L2 연관도 증가 | 4096 | 32 | 2 | 8192 | 32 | 4 | **1.0673** | ❌ 성능 저하 |
| 10 | L2 연관도 더 증가 | 4096 | 32 | 2 | 8192 | 32 | 8 | **1.0287** | ❌ 더 저하 |
| 11 | L1 연관도 감소 | 4096 | 32 | 1 | 8192 | 32 | 2 | **1.0842** | ❌ 약간 저하 |
| 12 | L1 블록 크기 더 감소 | 4096 | 16 | 2 | 8192 | 32 | 2 | **1.1224** | ✅ 큰 개선! |
| 13 | L2 블록 크기 더 감소 | 4096 | 16 | 2 | 8192 | 16 | 2 | **1.1067** | ❌ 약간 저하 |
| 14 | L1 크기 감소 | 2048 | 16 | 2 | 8192 | 32 | 2 | **1.1434** | ✅ **최고 점수!** |
| 15 | L1 크기 더 감소 | 1024 | 16 | 2 | 8192 | 32 | 2 | **1.1054** | ❌ 성능 저하 |
| 16 | L2 크기 감소 테스트 | 2048 | 16 | 2 | 4096 | 32 | 2 | **1.1125** | ❌ 약간 저하 |
| 17 | L1 연관도 감소 테스트 | 2048 | 16 | 1 | 8192 | 32 | 2 | **1.1261** | ❌ 약간 저하 |
| 18 | L2 연관도 감소 테스트 | 2048 | 16 | 2 | 8192 | 32 | 1 | **1.1423** | ❌ 미세한 저하 |

### 🏆 최적 설정 도출
```
configA
l1.cacheSize=2048
l1.blockSize=16
l1.associativity=2  
l2.cacheSize=8192
l2.blockSize=32
l2.associativity=2
bp=BPB
```

## 📈 성능 향상 결과

### 최종 성능 비교

| 성능 지표 | 초기 값 | 최적화 후 | 개선율 |
|-----------|---------|-----------|--------|
| **🏆 Benchmark Score** | **0.9744** | **1.1434** | **+17.3%** |
| 총 사이클 수 | 6,907,164 | 6,696,426 | **-3.1%** |
| CPI (Cycles per Instruction) | 1.6366 | 1.5867 | **-3.0%** |
| 명령어 수 | 4,220,359 | 4,220,359 | 동일 |

### 캐시 성능 향상

#### L1 캐시 성능
| 지표 | 초기 값 | 최적화 후 | 개선율 |
|------|---------|-----------|--------|
| 총 읽기 바이트 | 28,234,392 | 28,234,392 | 동일 |
| 총 쓰기 바이트 | 4,568,876 | 4,568,876 | 동일 |
| 히트 바이트 | 32,681,407 | 32,515,809 | -0.5% |
| **미스 바이트** | **121,861** | **287,459** | **+135.9%** |

#### L2 캐시 성능  
| 지표 | 초기 값 | 최적화 후 | 개선율 |
|------|---------|-----------|--------|
| 총 읽기 바이트 | 7,799,104 | 4,599,344 | **-41.0%** |
| 총 쓰기 바이트 | 4,596,864 | 4,216,400 | **-8.3%** |
| 히트 바이트 | 12,328,546 | 8,683,266 | **-29.6%** |
| **미스 바이트** | **67,422** | **132,478** | **+96.5%** |

### 파이프라인 성능 (동일)
- **Control Hazards**: 193,337
- **Data Hazards**: 3,241,017  
- **Memory Hazards**: 655,588
- **Branch Prediction Accuracy**: 74.04%

## 💡 핵심 최적화 인사이트

### 1. 블록 크기의 핵심적 역할
- **L1 블록 크기**: 64 → 16 (75% 감소)가 성능 향상의 핵심
- **L2 블록 크기**: 64 → 32 (50% 감소)로 추가 최적화
- **이유**: 작은 블록 크기가 이 워크로드의 메모리 패턴에 더 적합

### 2. 캐시 크기 최적화 
- **L1 크기**: 2048이 최적 (더 크거나 작으면 성능 저하)
- **L2 크기**: 16384 → 8192 (50% 감소)로 효율성 증대
- **trade-off**: 캐시 크기와 접근 지연시간의 균형점

### 3. 연관도의 미세 조정
- **L1, L2 모두 2-way 연관도**가 최적
- 높은 연관도는 복잡성 증가로 인한 성능 저하 유발

### 4. 메모리 계층 구조 최적화
- L1 미스가 증가했지만 전체 성능은 향상
- L2 접근 감소로 인한 전체적인 메모리 지연시간 단축

## 🎯 결론 및 활용 방안

### 주요 성과
1. **벤치마크 스코어 17.3% 향상** (0.9744 → 1.1434)
2. **사이클 수 3.1% 감소** (효율적인 명령어 실행)
3. **CPI 3.0% 개선** (명령어당 사이클 감소)

### 최적화 핵심 요인
- **작은 블록 크기**: 메모리 지역성 패턴에 최적화
- **적절한 캐시 크기**: 워킹셋과 지연시간의 균형
- **단순한 연관도**: 복잡성 vs 성능의 trade-off 최적화

### 실무 적용 가치
이 최적화 결과는 **임베디드 시스템**이나 **에너지 효율적 컴퓨팅**에서 캐시 시스템 설계 시 직접 활용 가능하며, 특히 **메모리 집약적 알고리즘**의 성능 튜닝에 유용한 가이드라인을 제시합니다.

---

*최적화 완료일: 2024년*  
*시뮬레이터: RISC-V Simulator v1.0*  
*총 테스트 횟수: 18회*
*최종 최적화율: +17.3%* 